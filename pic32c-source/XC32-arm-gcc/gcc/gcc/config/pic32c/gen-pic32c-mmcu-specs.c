/* Copyright (C) 2017 Free Software Foundation, Inc.
   Contributed by LG (lavinia.ghica@microchip.com)

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.
   
   GCC is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with GCC; see the file COPYING3.  If not see
   <http://www.gnu.org/licenses/>.  */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "pic32c-arch.h"
#include "../../version.h"

#define SPECFILE_DOC_URL                                \
  "https://gcc.gnu.org/onlinedocs/gcc/Spec-Files.html"

#define SPECFILE_USAGE_URL                              \
  "https://gcc.gnu.org/gcc-6/changes.html"

/* Return true iff STR starts with PREFIX.  */

static bool
str_prefix_p (const char *str, const char *prefix)
{
  return 0 == strncmp (str, prefix, strlen (prefix));
}


static const char header[] =
  "#\n"
  "# Generated by   : ./gcc/config/pic32c/gen-pic32c-mmcu-specs.c\n"
  "# Used by        : pic32c-gcc compiler driver\n"
  "# Used for       : building command options for sub-processes\n"
  "#\n"
  "# See <" SPECFILE_DOC_URL ">\n"
  "# for a documentation of spec files.\n"
  "\n";

static const char help_copy_paste[] =
  "# If you intend to use an existing device specs file as a starting point\n"
  "# for a new device spec file, make sure you are copying from a specs\n"
  "# file for a device from the same core architecture and SP width.\n"
  "# See <" SPECFILE_USAGE_URL "> for a description\n"
  "# of how to use such own spec files.\n";


///\ variable strings have spec_string = NULL
pic32c_spec_t pic32c_specs[] =
{
    {LIB_STARTUP,   "pic32clibc_startfile", "crti%O%s crtbegin%O%s crt0%O%s "},
    {DEVICE_LIB,    "pic32clibc_devicelib", NULL},
    {LIB,           "pic32c_lib", "--start-group -lpic32c %G %L --end-group "},
    {INST_SET,      "cc1_inst_set",         " %{!mthumb: -mthumb} "},
    {DEVICE_MACRO,  "cc1_device",           NULL},
    {DEVICE_FPU,    "cc1_fpu_device",       NULL},
    {CPP,           "cpp",                  "%{mfloat-abi=soft:%{mfloat-abi=hard:    \
                            %e-mfloat-abi=soft and -mfloat-abi=hard may not be used together}} " },
    {CC1_DEBUG,     "cc1_debug",            "%{D__DEBUG : -mdebugger}"},
    {CC1_SAVE_TEMPS,"cc1_save_temps",       "%{save-temps: -fverbose-asm}"},
    {ASM_ARCH,      "asm_arch",             NULL},
    {ASM_FLOAT,     "asm_float",            "%{mapcs-float: -mfloat}"},
    {ENDIANNESS,    "endianness",           "%{!mlittle-endian | !mbig-endian: -EL} \
                        %{mlittle-endian: -EL} %{mbig-endian: -EB}" },
    {LINKER_SCRIPT, "linker_script",        NULL},
    {CC1_SMARTIO,   "cc1_smartio",          "%{msmart-io:%{msmart-io=*:%emay not use both -msmart-io and -msmart-io=LEVEL}} \
        %{mno-smart-io:%{msmart-io=*:%emay not use both -mno-smart-io and -msmart-io=LEVEL}} \
        %{mno-smart-io:-msmart-io=0} \
        %{msmart-io:-msmart-io=1}" },
    {CC1_CONFIG_DATA, "cc1_config_data",    NULL},
    {LINKER_SMARTIO,"linker_smartio",       "%{mno-smart-io:--no-smart-io} %{msmart-io=0:--no-smart-io}" },
    /* End of list.  */
    {PIC32C_SPECS_END, NULL, NULL }
};

static void print_spec_name(FILE* f, pic32c_spec_id spec)
{
    if (spec >= PIC32C_SPECS_END)
    {
        fprintf(stderr, "Error: Wrong SPEC ID\n");
        exit(1);
    }
    
    if (pic32c_specs[spec].spec_name == NULL)
    {
        fprintf(stderr, "Error: Unnamed spec %d\n", spec);
        exit(1);
    }

    ///\ print spec name
    fprintf (f, "*%s:\n", pic32c_specs[spec].spec_name);
}

///\ used for specs that doesn't need device specific info
static void pic32c_print_generic_spec(FILE* f, pic32c_spec_id spec)
{
    print_spec_name(f, spec);
    
    if (pic32c_specs[spec].spec_string == NULL)
    {
        fprintf(stderr, "Error: Spec with variable string cannot be printed by pic32c_print_generic_spec\n");
        exit(1);
    }
    
    ///\ print spec string
    fprintf (f, "\t%s\n\n", pic32c_specs[spec].spec_string);
    
}


static void pic32c_generate_lib_specs(FILE* f,
                        const pic32c_mcu_t *mcu,
                        const pic32c_arch_t *arch)
{
    ///\ PIC32-LibC specific.
    ///\ See pic32c  libc.h for the specs using them as subspecs.
    
    pic32c_print_generic_spec(f, LIB_STARTUP);
    
    pic32c_print_generic_spec(f, LIB);
    
    print_spec_name(f, DEVICE_LIB);
    fprintf (f, "\t%%{!nodevicelib:-l%s}\n\n", mcu->name);
}

static void pic32c_generate_compiler_specs(FILE* f,
                        const pic32c_mcu_t *mcu,
                        const pic32c_arch_t *arch)
{
    pic32c_print_generic_spec(f, CPP);
    
    pic32c_print_generic_spec(f, INST_SET);
    
    print_spec_name(f, DEVICE_MACRO);
    fprintf (f,"\t -D%s \n\n", mcu->macro);
   
    // Set the default float-abi based on presence of an FPU.
    print_spec_name(f, DEVICE_FPU);
    fprintf (f, "\t %%{!mfloat-abi=*: ");
    if (mcu->fpu != NULL)
        fprintf(f, "\t-mfloat-abi=hard ");
    else
        fprintf(f, "\t-mfloat-abi=soft ");
    fprintf(f, "}");
    // Set the mfpu default if an FPU is present.
    if (mcu->fpu != NULL)
        fprintf(f, " %%{mfpu=* : -mfpu=%%* ;: %%{mfloat-abi=soft: -mfloat-abi=soft ;: -mfpu=%s }}", mcu->fpu);
    fprintf(f, "\n\n");

    pic32c_print_generic_spec(f, CC1_DEBUG);
    
    pic32c_print_generic_spec(f, CC1_SAVE_TEMPS);
    
    pic32c_print_generic_spec(f, CC1_SMARTIO);

    print_spec_name(f, CC1_CONFIG_DATA);
    fprintf (f,"\t -mconfig-data-file=%%R/lib/proc/%s/configuration.data \n\n", mcu->name);

}


static void pic32c_generate_assembler_specs(FILE* f,
                        const pic32c_mcu_t *mcu,
                        const pic32c_arch_t *arch)
{
    print_spec_name(f, ASM_ARCH);
    fprintf (f, "\t-mcpu=%s -mthumb\n\n", arch->core_name);
    
    pic32c_print_generic_spec(f, ASM_FLOAT);
}

static void pic32c_tolower(const char* const name, char* const tolower_name);


static void pic32c_generate_linker_specs(FILE* f,
                        const pic32c_mcu_t *mcu,
                        const pic32c_arch_t *arch)
{

    char * tolower_name = (char*)malloc((strlen(mcu->name)+1)*sizeof(char));
    
    
    if (tolower_name == NULL)
        tolower_name = (char*)mcu->name;
    else
    {
        memset(tolower_name, 0, (strlen(mcu->name)+1));
        pic32c_tolower(mcu->name, tolower_name);
    }
    
    pic32c_print_generic_spec(f, ENDIANNESS);
 
    
    ///\ linker script
    fprintf(f, "# to be adjusted once the place of linker scripts is established\n");
    print_spec_name(f, LINKER_SCRIPT);
    fprintf(f, "\t %%{!T:-T %%R/lib/proc/%s/%s.ld } \n\n",
            mcu->name, mcu->name);
    
    pic32c_print_generic_spec(f, LINKER_SMARTIO);

}

static void print_compiler_version(FILE *f)
{
    fprintf(f, "#%s\n", version_string);
}


static void pic32c_tolower(const char* const name, char* const tolower_name)
{
    int i;
    char *ptr;
    
    for (i = 0 ; i < strlen(name); i++)
    {
        if ((name[i] >= 'A') && (name[i] <= 'Z'))
            tolower_name[i] = name[i] + ('a' - 'A');
        else
            tolower_name[i] = name[i];
    }
    ///\ end of string
    tolower_name[i] = '\0';
}

static void
pic32c_generate_self_spec(FILE* f,
                          const pic32c_mcu_t *mcu,
                          const pic32c_arch_t *arch)
{
    char * tolower_name = (char*)malloc((strlen(mcu->name)+1)*sizeof(char));
    if (tolower_name == NULL)
        tolower_name = (char*)mcu->name;
    else
    {
        memset(tolower_name, 0, (strlen(mcu->name)+1));
        pic32c_tolower(mcu->name, tolower_name);
    }

    fprintf (f, "*self_spec:\n");
    fprintf (f, "\t%%{mcpu=*: -mcpu=%%* ;: -mcpu=%s} -mthumb %%{!flto : -fno-lto} ", arch->core_name);
    
    ///\ fpu generation
    // Set the default float-abi based on presence of an FPU.
    fprintf (f, " %%{mfloat-abi=*: -mfloat-abi=%%* ;: ");
    if (mcu->fpu != NULL)
        fprintf(f, "-mfloat-abi=hard ");
    else
        fprintf(f, "-mfloat-abi=soft ");
    fprintf(f, "} ");
    // Set the mfpu default if an FPU is present.
    if (mcu->fpu != NULL)
        fprintf(f, " %%{mfpu=*: -mfpu=%%* ;: %%{!mfloat-abi=soft: -mfpu=%s }}", mcu->fpu);
        
    ///\ tcm
    fprintf(f, "\t%%{mitcm=*:-Wl,-D__XC32_ITCM_LENGTH=%%*,-itcm=%%* -D__XC32_ENABLE_TCM -D__XC32_ITCM_LENGTH=%%*} ");
    fprintf(f, "\t%%{mdtcm=*:-Wl,-D__XC32_DTCM_LENGTH=%%*,-dtcm=%%* -D__XC32_ENABLE_TCM -D__XC32_DTCM_LENGTH=%%*} ");
    ///\ stack in tcm
    fprintf(f, "\t%%{mstack-in-tcm: -Wl,-stack-in-tcm -D__XC32_ENABLE_TCM} ");
    

    ///\ add startup
    fprintf(f, "\t %%{!c: %%{!S: %%{!E: %%{!mno-device-startup-code: %%R/lib/proc/%s/startup_%s.c }}}} ", mcu->name, tolower_name);
    fprintf(f, " \n\n");
    
    if (tolower_name != mcu->name)
        free(tolower_name);
}

static void
print_mcu (const pic32c_mcu_t*  mcu)
{
    const pic32c_mcu_t *arch_mcu;
    const pic32c_arch_t *arch;
    enum pic32c_arch_id arch_id = mcu->arch_id;
    char name[100];

    arch = &pic32c_arch_types[arch_id-1];
    
    printf ("SPECS - %s\n", mcu->name);
    
    if (snprintf (name, sizeof name, "specs-%s", mcu->name) >= (int) sizeof name)
        exit (EXIT_FAILURE);

    printf ("file name - %s\n", name);
    
    FILE *f = fopen (name ,"w");

    bool is_arch = NULL == mcu->macro;
    bool is_device = ! is_arch;

    print_compiler_version(f);
    
    fprintf (f, "#\n"
           "# Auto-generated specs for PIC32C ");
    
    fprintf (f, "%s\n", header);

    if (is_device)
        fprintf (f, "%s\n", help_copy_paste);
    

    ///\ pic32c-gcc specs for libs
    pic32c_generate_lib_specs(f, mcu, arch);
    
    ///\ pic32c-gcc specs for compiler
    pic32c_generate_compiler_specs(f, mcu, arch);
    

    ///\ pic32c-gcc specs for assembler
    pic32c_generate_assembler_specs(f, mcu, arch);

    ///\ pic32c-gcc specs for linker
    pic32c_generate_linker_specs(f, mcu, arch);
    
    ///\ pic32c-gcc self specs
    pic32c_generate_self_spec(f, mcu, arch);
    
    fprintf (f, "# End of file\n");

    fclose (f);
}


/*
 * first argument, if present, should be compiler version
 */
int main (int argc, char** args)
{
    const pic32c_mcu_t *mcu = pic32c_mcu_types;
    
    for (; mcu->name; mcu++)
        print_mcu (mcu);

  return EXIT_SUCCESS;
}
